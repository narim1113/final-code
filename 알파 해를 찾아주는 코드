function solve_alpha_symbolic()
% θ=1에서 g0(θ,α)=0, g1(θ,α,α1)=0을 풀어 α, α1을 구하고
% 해를 좌표 A,B,C,D,E,G에 대입하여 3D로 시각화 (모든 좌표 라벨 포함)

%% ===== 고정값 =====
TH = 1;                              % theta = 1 (rad)
gamma = pi/7; %동일하게 7의 자리에 원하는 패널의 수의 값인 m을 대입해주면 된다.
beta  = pi/8;
a     = 1;

%% ===== 심볼릭 변수 =====
% alpha, alpha1: 수치 루트 탐색 변수로 사용
% (심볼릭 제거: numeric 클로저로 평가)

%% ===== A,B,C 정의 (B는 θ만 의존) =====
A = [cos(2*gamma); sin(2*gamma); 0];
Bx = cos(2*gamma) + 2*sin(gamma)*tan(beta)*cos(TH)*cos(gamma);
By = sin(2*gamma) + 2*sin(gamma)^2*tan(beta)*cos(TH);
Bz = 2*sin(gamma)*tan(beta)*sin(TH);
B  = [Bx; By; Bz];
C  = [1; 0; 0];

%% ===== 1차 프레임 (A 기준) =====
u  = unit(B - A);
n1 = unit(cross(C - A, B - A));
% n2는 α에 의존 → DE/E 프레임 내부에서 수치로 생성
x_dir = u; % 표시용(초깃값)
z_dir = n1; % 표시용(초깃값)
y_dir = cross(z_dir, x_dir);
M = [x_dir, y_dir, z_dir];   % 표시용(초깃값)

%% ===== 길이 및 로컬 좌표 =====
L_AB = 2*a*sin(gamma)*tan(beta);
L_AD = 2*sin(gamma);
L_DE = 4*a*sin(gamma)*tan(beta);
L_BE = (2*a*sin(gamma))/cos(beta);

A0 = [0;0;0];
B0 = [L_AB;0;0];
D0 = [0;L_AD;0];

d   = norm(B0 - D0);
ap  = (L_DE^2 - L_BE^2 + d^2) / (2*d);
h2  = max(L_DE^2 - ap^2,0);
h   = sqrt(h2);
dir = (B0 - D0)/d;
prp = [-dir(2); dir(1); 0];
E0  = D0 + ap*dir + h*prp;

%% ===== 글로벌 D,E 및 회전된 점 B',E' =====
Rz   = [cos(2*gamma) -sin(2*gamma) 0; sin(2*gamma) cos(2*gamma) 0; 0 0 1];
Brot = Rz * B;
% Dg, Eg는 α에 의존 → 수치 클로저로 생성
DEg = @(ak) deal( A + M_from(a,u,n1,ak)*D0 , A + M_from(a,u,n1,ak)*E0 );

%% ===== 관계식 #1: g0(theta=1, alpha)=0 =====
g0_fun = @(ak) ( sum((Brot - (A + M_from(a,u,n1,ak)*D0)).^2) - (4*sin(gamma)^2*tan(beta)^2) );

alpha_roots = find_roots_1D(@(a_) g0_fun(a_), -pi, pi, 1601);
if isempty(alpha_roots)
    error('θ=1에서 g0(θ,α)=0 의 실수 해를 찾지 못했습니다.');
end

%% ===== 두 번째 프레임 및 g1: 심볼릭 막힘 방지용 "숫자 평가"로 변경 =====
gd=gamma; bd=beta; ad=a; THd=TH;
g1_eval = @(ak,a1) g1_numeric(ak,a1,gd,bd,ad,THd); % g1 값과 G 좌표를 숫자로 산출

%% ===== 좌표 기본 =====
A_num = A; B_num = B; C_num = C;

figure('Name','A,B,C,D,E,G for θ=1','Color','w');
ax = axes; hold(ax,'on'); grid(ax,'on'); axis(ax,'equal'); axis(ax,'vis3d'); view(ax,45,25);
xlabel(ax,'X'); ylabel(ax,'Y'); zlabel(ax,'Z');
title(ax,'A,B,C,D,E,G for θ=1 (모든 좌표 표시)');
cols = lines(max(7,numel(alpha_roots)));

fprintf('\n=== θ = 1 (rad) ===\n');
fprintf('A = [% .8f, % .8f, % .8f]\n', A_num);
fprintf('B = [% .8f, % .8f, % .8f]\n', B_num);
fprintf('C = [% .8f, % .8f, % .8f]\n', C_num);

for k = 1:numel(alpha_roots)
    ak = alpha_roots(k);

    % g1(ak, a1) = 0의 루트 탐색 (숫자 평가)
    f_alpha1 = @(a1) g1_eval(ak, a1);
    a1_roots = find_roots_1D(f_alpha1, -pi, pi, 2001);

    [D_num, E_num] = DEg(ak);
    cc = cols(mod(k-1,size(cols,1))+1,:);

    plot3(ax, [A_num(1) B_num(1) C_num(1) D_num(1) E_num(1)], ...
              [A_num(2) B_num(2) C_num(2) D_num(2) E_num(2)], ...
              [A_num(3) B_num(3) C_num(3) D_num(3) E_num(3)], ...
              'o','Color',cc,'MarkerFaceColor',cc,'DisplayName',sprintf('α root %d',k));
    line([A_num(1) B_num(1)],[A_num(2) B_num(2)],[A_num(3) B_num(3)],'Color',cc);
    line([A_num(1) C_num(1)],[A_num(2) C_num(2)],[A_num(3) C_num(3)],'Color',cc);
    line([A_num(1) D_num(1)],[A_num(2) D_num(2)],[A_num(3) D_num(3)],'Color',cc);
    line([D_num(1) E_num(1)],[D_num(2) E_num(2)],[D_num(3) E_num(3)],'Color',cc);

    % 각 점 라벨 표시
    text(A_num(1),A_num(2),A_num(3),' A','Color',cc);
    text(B_num(1),B_num(2),B_num(3),' B','Color',cc);
    text(C_num(1),C_num(2),C_num(3),' C','Color',cc);
    text(D_num(1),D_num(2),D_num(3),' D','Color',cc);
    text(E_num(1),E_num(2),E_num(3),' E','Color',cc);

    fprintf('\n-- alpha root %d: alpha = %.12f --\n', k, ak);
    fprintf('D = [% .8f, % .8f, % .8f]\n', D_num);
    fprintf('E = [% .8f, % .8f, % .8f]\n', E_num);

    for r = 1:numel(a1_roots)
        a1k  = a1_roots(r);
        [~,G_num] = g1_numeric(ak,a1k,gd,bd,ad,THd);  % 숫자 평가로 G 좌표 획득
        plot3(ax, G_num(1),G_num(2),G_num(3),'s','MarkerSize',8,...
              'MarkerFaceColor',cc,'Color',cc,'DisplayName',sprintf('G (α%d, α1=%.3f)',k,a1k));
        line([E_num(1) G_num(1)],[E_num(2) G_num(2)],[E_num(3) G_num(3)],'Color',cc,'LineWidth',1.3);
        text(G_num(1),G_num(2),G_num(3),sprintf(' G(α%d,α1=%.2f)',k,a1k),'Color',cc);
        fprintf('G (α1 = %.12f) = [% .8f, % .8f, % .8f]\n', a1k, G_num);
    end
end

legend(ax,'Location','northeastoutside');
end


%% ======== 보조 루틴들 ========
function roots = find_roots_1D(fun, a_min, a_max, n_samples)
xs = linspace(a_min, a_max, n_samples);
F  = arrayfun(@(x) safe_eval(@() fun(x)), xs);
roots = [];
good = isfinite(F);
idx  = find(good);
for k = 1:numel(idx)-1
    i = idx(k); j = idx(k+1);
    if sign(F(i)) ~= sign(F(j))
        try
            r = fzero(@(x) fun(x), [xs(i) xs(j)]);
            if isfinite(r), roots = [roots; r]; end %#ok<AGROW>
        end
    end
end
roots = unique_tol(roots, 1e-8);
end

function v = safe_eval(fh)
try
    v = fh();
    if ~isfinite(v), v = NaN; end
catch
    v = NaN;
end
end

function u = unique_tol(x, tol)
if isempty(x), u = x; return; end
x = sort(x(:));
u = x(1);
for i=2:numel(x)
    if abs(x(i)-u(end)) > tol
        u(end+1) = x(i); %#ok<AGROW>
    end
end
end

%% ======== g1 숫자 평가기 ========
% g(α,α1) = ||Erot(γ) - G(α,α1)||^2 - (4*a*sin(γ)*tan(β))^2
% 두 번째 출력으로 G 좌표 반환(플롯용)
function [gval,G]=g1_numeric(ak,a1,gm,bt,aval,TH)
A=[cos(2*gm);sin(2*gm);0];
Bx=cos(2*gm)+2*sin(gm)*tan(bt)*cos(TH)*cos(gm);
By=sin(2*gm)+2*sin(gm)^2*tan(bt)*cos(TH);
Bz=2*sin(gm)*tan(bt)*sin(TH);
B=[Bx;By;Bz]; C=[1;0;0];

u=unit(B-A); n1=unit(cross(C-A,B-A));
n2=(-1)*(cos(ak)*n1+sin(ak)*cross(u,n1)+(1-cos(ak))*dot(u,n1)*u);
x_dir=u; z_dir=unit(n2); y_dir=cross(z_dir,x_dir);
M=[x_dir,y_dir,z_dir];

L_AB=2*aval*sin(gm)*tan(bt); L_AD=2*sin(gm);
L_DE=4*aval*sin(gm)*tan(bt); L_BE=(2*aval*sin(gm))/cos(bt);
A0=[0;0;0]; B0=[L_AB;0;0]; D0=[0;L_AD;0];
d=norm(B0-D0); ap=(L_DE^2-L_BE^2+d^2)/(2*d);
h=sqrt(max(L_DE^2-ap^2,0));
dir=(B0-D0)/d; prp=[-dir(2);dir(1);0];
E0=D0+ap*dir+h*prp;

Dg=A+M*D0; Eg=A+M*E0;
Rz=[cos(2*gm) -sin(2*gm) 0; sin(2*gm) cos(2*gm) 0; 0 0 1];
Erot=Rz*Eg;

u1=unit(Eg-Dg);
n3=(-1)*(cos(a1)*n2+sin(a1)*cross(u1,n2)+(1-cos(a1))*dot(u1,n1)*u1); % (원본 식 유지)
x1=u1; z1=unit(n3); y1=cross(z1,x1);
M1=[x1,y1,z1]; L_DG=2*sin(gm); G0=[0;L_DG;0];
G=Dg+M1*G0;

gval=sum((Erot-G).^2)-(4*aval*sin(gm)*tan(bt))^2;
end

function e=unit(v)
n=norm(v); if n==0, e=[0;0;0]; else, e=v/n; end
end

%% ======== 내부 유틸: α→회전행렬 ========
function M = M_from(~,u,n1,ak)
n2=(-1)*(cos(ak)*n1+sin(ak)*cross(u,n1)+(1-cos(ak))*dot(u,n1)*u);
x_dir=u; z_dir=unit(n2); y_dir=cross(z_dir,x_dir);
M=[x_dir,y_dir,z_dir];
end
